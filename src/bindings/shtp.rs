/* automatically generated by rust-bindgen 0.59.1 */

pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const SH2_HAL_MAX_TRANSFER_OUT: u32 = 256;
pub const SH2_HAL_MAX_PAYLOAD_OUT: u32 = 256;
pub const SH2_HAL_MAX_TRANSFER_IN: u32 = 384;
pub const SH2_HAL_MAX_PAYLOAD_IN: u32 = 384;
pub const SH2_HAL_DMA_SIZE: u32 = 512;
pub const SH2_MAX_SENSOR_EVENT_LEN: u32 = 16;
pub const SH2_MAX_PROD_ID_ENTRIES: u32 = 5;
pub const STATIC_CALIBRATION_AGM: u32 = 31097;
pub const NOMINAL_CALIBRATION: u32 = 19789;
pub const STATIC_CALIBRATION_SRA: u32 = 35466;
pub const NOMINAL_CALIBRATION_SRA: u32 = 20046;
pub const DYNAMIC_CALIBRATION: u32 = 7967;
pub const ME_POWER_MGMT: u32 = 54242;
pub const SYSTEM_ORIENTATION: u32 = 11582;
pub const ACCEL_ORIENTATION: u32 = 11585;
pub const SCREEN_ACCEL_ORIENTATION: u32 = 11587;
pub const GYROSCOPE_ORIENTATION: u32 = 11590;
pub const MAGNETOMETER_ORIENTATION: u32 = 11596;
pub const ARVR_STABILIZATION_RV: u32 = 15917;
pub const ARVR_STABILIZATION_GRV: u32 = 15918;
pub const TAP_DETECT_CONFIG: u32 = 49769;
pub const SIG_MOTION_DETECT_CONFIG: u32 = 49780;
pub const SHAKE_DETECT_CONFIG: u32 = 32125;
pub const MAX_FUSION_PERIOD: u32 = 55255;
pub const SERIAL_NUMBER: u32 = 19275;
pub const ES_PRESSURE_CAL: u32 = 14767;
pub const ES_TEMPERATURE_CAL: u32 = 19744;
pub const ES_HUMIDITY_CAL: u32 = 6857;
pub const ES_AMBIENT_LIGHT_CAL: u32 = 14769;
pub const ES_PROXIMITY_CAL: u32 = 19874;
pub const ALS_CAL: u32 = 54273;
pub const PROXIMITY_SENSOR_CAL: u32 = 54274;
pub const PICKUP_DETECTOR_CONFIG: u32 = 6954;
pub const FLIP_DETECTOR_CONFIG: u32 = 64660;
pub const STABILITY_DETECTOR_CONFIG: u32 = 60805;
pub const ACTIVITY_TRACKER_CONFIG: u32 = 60808;
pub const SLEEP_DETECTOR_CONFIG: u32 = 60807;
pub const TILT_DETECTOR_CONFIG: u32 = 60809;
pub const POCKET_DETECTOR_CONFIG: u32 = 61223;
pub const CIRCLE_DETECTOR_CONFIG: u32 = 61009;
pub const USER_RECORD: u32 = 29876;
pub const ME_TIME_SOURCE_SELECT: u32 = 54275;
pub const UART_FORMAT: u32 = 41377;
pub const GYRO_INTEGRATED_RV_CONFIG: u32 = 41378;
pub const FRS_ID_META_RAW_ACCELEROMETER: u32 = 58113;
pub const FRS_ID_META_ACCELEROMETER: u32 = 58114;
pub const FRS_ID_META_LINEAR_ACCELERATION: u32 = 58115;
pub const FRS_ID_META_GRAVITY: u32 = 58116;
pub const FRS_ID_META_RAW_GYROSCOPE: u32 = 58117;
pub const FRS_ID_META_GYROSCOPE_CALIBRATED: u32 = 58118;
pub const FRS_ID_META_GYROSCOPE_UNCALIBRATED: u32 = 58119;
pub const FRS_ID_META_RAW_MAGNETOMETER: u32 = 58120;
pub const FRS_ID_META_MAGNETIC_FIELD_CALIBRATED: u32 = 58121;
pub const FRS_ID_META_MAGNETIC_FIELD_UNCALIBRATED: u32 = 58122;
pub const FRS_ID_META_ROTATION_VECTOR: u32 = 58123;
pub const FRS_ID_META_GAME_ROTATION_VECTOR: u32 = 58124;
pub const FRS_ID_META_GEOMAGNETIC_ROTATION_VECTOR: u32 = 58125;
pub const FRS_ID_META_PRESSURE: u32 = 58126;
pub const FRS_ID_META_AMBIENT_LIGHT: u32 = 58127;
pub const FRS_ID_META_HUMIDITY: u32 = 58128;
pub const FRS_ID_META_PROXIMITY: u32 = 58129;
pub const FRS_ID_META_TEMPERATURE: u32 = 58130;
pub const FRS_ID_META_TAP_DETECTOR: u32 = 58131;
pub const FRS_ID_META_STEP_DETECTOR: u32 = 58132;
pub const FRS_ID_META_STEP_COUNTER: u32 = 58133;
pub const FRS_ID_META_SIGNIFICANT_MOTION: u32 = 58134;
pub const FRS_ID_META_STABILITY_CLASSIFIER: u32 = 58135;
pub const FRS_ID_META_SHAKE_DETECTOR: u32 = 58136;
pub const FRS_ID_META_FLIP_DETECTOR: u32 = 58137;
pub const FRS_ID_META_PICKUP_DETECTOR: u32 = 58138;
pub const FRS_ID_META_STABILITY_DETECTOR: u32 = 58139;
pub const FRS_ID_META_PERSONAL_ACTIVITY_CLASSIFIER: u32 = 58140;
pub const FRS_ID_META_SLEEP_DETECTOR: u32 = 58141;
pub const FRS_ID_META_TILT_DETECTOR: u32 = 58142;
pub const FRS_ID_META_POCKET_DETECTOR: u32 = 58143;
pub const FRS_ID_META_CIRCLE_DETECTOR: u32 = 58144;
pub const FRS_ID_META_HEART_RATE_MONITOR: u32 = 58145;
pub const FRS_ID_META_ARVR_STABILIZED_RV: u32 = 58146;
pub const FRS_ID_META_ARVR_STABILIZED_GRV: u32 = 58147;
pub const FRS_ID_META_GYRO_INTEGRATED_RV: u32 = 58148;
pub const SH2_CAL_ACCEL: u32 = 1;
pub const SH2_CAL_GYRO: u32 = 2;
pub const SH2_CAL_MAG: u32 = 4;
pub const SH2_CAL_PLANAR: u32 = 8;
pub const SH2_OK: u32 = 0;
pub const SH2_ERR: i32 = -1;
pub const SH2_ERR_BAD_PARAM: i32 = -2;
pub const SH2_ERR_OP_IN_PROGRESS: i32 = -3;
pub const SH2_ERR_IO: i32 = -4;
pub const SH2_ERR_HUB: i32 = -5;
pub const SH2_ERR_TIMEOUT: i32 = -6;
pub const TAPDET_X: u32 = 1;
pub const TAPDET_X_POS: u32 = 2;
pub const TAPDET_Y: u32 = 4;
pub const TAPDET_Y_POS: u32 = 8;
pub const TAPDET_Z: u32 = 16;
pub const TAPDET_Z_POS: u32 = 32;
pub const TAPDET_DOUBLE: u32 = 64;
pub const STABILITY_CLASSIFIER_UNKNOWN: u32 = 0;
pub const STABILITY_CLASSIFIER_ON_TABLE: u32 = 1;
pub const STABILITY_CLASSIFIER_STATIONARY: u32 = 2;
pub const STABILITY_CLASSIFIER_STABLE: u32 = 3;
pub const STABILITY_CLASSIFIER_MOTION: u32 = 4;
pub const SHAKE_X: u32 = 1;
pub const SHAKE_Y: u32 = 2;
pub const SHAKE_Z: u32 = 4;
pub const PICKUP_LEVEL_TO_NOT_LEVEL: u32 = 1;
pub const PICKUP_STOP_WITHIN_REGION: u32 = 2;
pub const STABILITY_ENTERED: u32 = 1;
pub const STABILITY_EXITED: u32 = 2;
pub const PAC_UNKNOWN: u32 = 0;
pub const PAC_IN_VEHICLE: u32 = 1;
pub const PAC_ON_BICYCLE: u32 = 2;
pub const PAC_ON_FOOT: u32 = 3;
pub const PAC_STILL: u32 = 4;
pub const PAC_TILTING: u32 = 5;
pub const PAC_WALKING: u32 = 6;
pub const PAC_RUNNING: u32 = 7;
pub const TAG_NULL: u32 = 0;
pub const TAG_GUID: u32 = 1;
pub const TAG_MAX_CARGO_PLUS_HEADER_WRITE: u32 = 2;
pub const TAG_MAX_CARGO_PLUS_HEADER_READ: u32 = 3;
pub const TAG_MAX_TRANSFER_WRITE: u32 = 4;
pub const TAG_MAX_TRANSFER_READ: u32 = 5;
pub const TAG_NORMAL_CHANNEL: u32 = 6;
pub const TAG_WAKE_CHANNEL: u32 = 7;
pub const TAG_APP_NAME: u32 = 8;
pub const TAG_CHANNEL_NAME: u32 = 9;
pub const TAG_ADV_COUNT: u32 = 10;
pub const TAG_APP_SPECIFIC: u32 = 128;
pub type int_least64_t = i64;
pub type uint_least64_t = u64;
pub type int_fast64_t = i64;
pub type uint_fast64_t = u64;
pub type int_least32_t = i32;
pub type uint_least32_t = u32;
pub type int_fast32_t = i32;
pub type uint_fast32_t = u32;
pub type int_least16_t = i16;
pub type uint_least16_t = u16;
pub type int_fast16_t = i16;
pub type uint_fast16_t = u16;
pub type int_least8_t = i8;
pub type uint_least8_t = u8;
pub type int_fast8_t = i8;
pub type uint_fast8_t = u8;
pub type intmax_t = cty::c_longlong;
pub type uintmax_t = cty::c_ulonglong;
pub type sh2_Hal_t = sh2_Hal_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_Hal_s {
    pub open: ::core::option::Option<unsafe extern "C" fn(self_: *mut sh2_Hal_t) -> cty::c_int>,
    pub close: ::core::option::Option<unsafe extern "C" fn(self_: *mut sh2_Hal_t)>,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut sh2_Hal_t,
            pBuffer: *mut u8,
            len: cty::c_uint,
            t_us: *mut u32,
        ) -> cty::c_int,
    >,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut sh2_Hal_t,
            pBuffer: *mut u8,
            len: cty::c_uint,
        ) -> cty::c_int,
    >,
    pub getTimeUs: ::core::option::Option<unsafe extern "C" fn(self_: *mut sh2_Hal_t) -> u32>,
}
#[test]
fn bindgen_test_layout_sh2_Hal_s() {
    assert_eq!(
        ::core::mem::size_of::<sh2_Hal_s>(),
        20usize,
        concat!("Size of: ", stringify!(sh2_Hal_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_Hal_s>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_Hal_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_Hal_s>())).open as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_Hal_s),
            "::",
            stringify!(open)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_Hal_s>())).close as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_Hal_s),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_Hal_s>())).read as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_Hal_s),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_Hal_s>())).write as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_Hal_s),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_Hal_s>())).getTimeUs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_Hal_s),
            "::",
            stringify!(getTimeUs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_SensorEvent {
    pub timestamp_uS: u64,
    pub len: u8,
    pub reportId: u8,
    pub report: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_sh2_SensorEvent() {
    assert_eq!(
        ::core::mem::size_of::<sh2_SensorEvent>(),
        32usize,
        concat!("Size of: ", stringify!(sh2_SensorEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_SensorEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(sh2_SensorEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_SensorEvent>())).timestamp_uS as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorEvent),
            "::",
            stringify!(timestamp_uS)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_SensorEvent>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorEvent),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_SensorEvent>())).reportId as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorEvent),
            "::",
            stringify!(reportId)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_SensorEvent>())).report as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorEvent),
            "::",
            stringify!(report)
        )
    );
}
pub type sh2_SensorEvent_t = sh2_SensorEvent;
pub type sh2_SensorCallback_t = ::core::option::Option<
    unsafe extern "C" fn(cookie: *mut cty::c_void, pEvent: *mut sh2_SensorEvent_t),
>;
#[doc = " @brief Product Id value"]
#[doc = ""]
#[doc = " See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_ProductId_s {
    pub resetCause: u8,
    pub swVersionMajor: u8,
    pub swVersionMinor: u8,
    pub swPartNumber: u32,
    pub swBuildNumber: u32,
    pub swVersionPatch: u16,
    pub reserved0: u8,
    pub reserved1: u8,
}
#[test]
fn bindgen_test_layout_sh2_ProductId_s() {
    assert_eq!(
        ::core::mem::size_of::<sh2_ProductId_s>(),
        16usize,
        concat!("Size of: ", stringify!(sh2_ProductId_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_ProductId_s>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_ProductId_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_ProductId_s>())).resetCause as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_ProductId_s),
            "::",
            stringify!(resetCause)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_ProductId_s>())).swVersionMajor as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_ProductId_s),
            "::",
            stringify!(swVersionMajor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_ProductId_s>())).swVersionMinor as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_ProductId_s),
            "::",
            stringify!(swVersionMinor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_ProductId_s>())).swPartNumber as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_ProductId_s),
            "::",
            stringify!(swPartNumber)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_ProductId_s>())).swBuildNumber as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_ProductId_s),
            "::",
            stringify!(swBuildNumber)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_ProductId_s>())).swVersionPatch as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_ProductId_s),
            "::",
            stringify!(swVersionPatch)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_ProductId_s>())).reserved0 as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_ProductId_s),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_ProductId_s>())).reserved1 as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_ProductId_s),
            "::",
            stringify!(reserved1)
        )
    );
}
pub type sh2_ProductId_t = sh2_ProductId_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_ProductIds_s {
    pub entry: [sh2_ProductId_t; 5usize],
    pub numEntries: u8,
}
#[test]
fn bindgen_test_layout_sh2_ProductIds_s() {
    assert_eq!(
        ::core::mem::size_of::<sh2_ProductIds_s>(),
        84usize,
        concat!("Size of: ", stringify!(sh2_ProductIds_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_ProductIds_s>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_ProductIds_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_ProductIds_s>())).entry as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_ProductIds_s),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_ProductIds_s>())).numEntries as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_ProductIds_s),
            "::",
            stringify!(numEntries)
        )
    );
}
pub type sh2_ProductIds_t = sh2_ProductIds_s;
pub const sh2_SensorId_e_SH2_RAW_ACCELEROMETER: sh2_SensorId_e = 20;
pub const sh2_SensorId_e_SH2_ACCELEROMETER: sh2_SensorId_e = 1;
pub const sh2_SensorId_e_SH2_LINEAR_ACCELERATION: sh2_SensorId_e = 4;
pub const sh2_SensorId_e_SH2_GRAVITY: sh2_SensorId_e = 6;
pub const sh2_SensorId_e_SH2_RAW_GYROSCOPE: sh2_SensorId_e = 21;
pub const sh2_SensorId_e_SH2_GYROSCOPE_CALIBRATED: sh2_SensorId_e = 2;
pub const sh2_SensorId_e_SH2_GYROSCOPE_UNCALIBRATED: sh2_SensorId_e = 7;
pub const sh2_SensorId_e_SH2_RAW_MAGNETOMETER: sh2_SensorId_e = 22;
pub const sh2_SensorId_e_SH2_MAGNETIC_FIELD_CALIBRATED: sh2_SensorId_e = 3;
pub const sh2_SensorId_e_SH2_MAGNETIC_FIELD_UNCALIBRATED: sh2_SensorId_e = 15;
pub const sh2_SensorId_e_SH2_ROTATION_VECTOR: sh2_SensorId_e = 5;
pub const sh2_SensorId_e_SH2_GAME_ROTATION_VECTOR: sh2_SensorId_e = 8;
pub const sh2_SensorId_e_SH2_GEOMAGNETIC_ROTATION_VECTOR: sh2_SensorId_e = 9;
pub const sh2_SensorId_e_SH2_PRESSURE: sh2_SensorId_e = 10;
pub const sh2_SensorId_e_SH2_AMBIENT_LIGHT: sh2_SensorId_e = 11;
pub const sh2_SensorId_e_SH2_HUMIDITY: sh2_SensorId_e = 12;
pub const sh2_SensorId_e_SH2_PROXIMITY: sh2_SensorId_e = 13;
pub const sh2_SensorId_e_SH2_TEMPERATURE: sh2_SensorId_e = 14;
pub const sh2_SensorId_e_SH2_RESERVED: sh2_SensorId_e = 23;
pub const sh2_SensorId_e_SH2_TAP_DETECTOR: sh2_SensorId_e = 16;
pub const sh2_SensorId_e_SH2_STEP_DETECTOR: sh2_SensorId_e = 24;
pub const sh2_SensorId_e_SH2_STEP_COUNTER: sh2_SensorId_e = 17;
pub const sh2_SensorId_e_SH2_SIGNIFICANT_MOTION: sh2_SensorId_e = 18;
pub const sh2_SensorId_e_SH2_STABILITY_CLASSIFIER: sh2_SensorId_e = 19;
pub const sh2_SensorId_e_SH2_SHAKE_DETECTOR: sh2_SensorId_e = 25;
pub const sh2_SensorId_e_SH2_FLIP_DETECTOR: sh2_SensorId_e = 26;
pub const sh2_SensorId_e_SH2_PICKUP_DETECTOR: sh2_SensorId_e = 27;
pub const sh2_SensorId_e_SH2_STABILITY_DETECTOR: sh2_SensorId_e = 28;
pub const sh2_SensorId_e_SH2_PERSONAL_ACTIVITY_CLASSIFIER: sh2_SensorId_e = 30;
pub const sh2_SensorId_e_SH2_SLEEP_DETECTOR: sh2_SensorId_e = 31;
pub const sh2_SensorId_e_SH2_TILT_DETECTOR: sh2_SensorId_e = 32;
pub const sh2_SensorId_e_SH2_POCKET_DETECTOR: sh2_SensorId_e = 33;
pub const sh2_SensorId_e_SH2_CIRCLE_DETECTOR: sh2_SensorId_e = 34;
pub const sh2_SensorId_e_SH2_HEART_RATE_MONITOR: sh2_SensorId_e = 35;
pub const sh2_SensorId_e_SH2_ARVR_STABILIZED_RV: sh2_SensorId_e = 40;
pub const sh2_SensorId_e_SH2_ARVR_STABILIZED_GRV: sh2_SensorId_e = 41;
pub const sh2_SensorId_e_SH2_GYRO_INTEGRATED_RV: sh2_SensorId_e = 42;
pub const sh2_SensorId_e_SH2_IZRO_MOTION_REQUEST: sh2_SensorId_e = 43;
pub const sh2_SensorId_e_SH2_MAX_SENSOR_ID: sh2_SensorId_e = 43;
#[doc = " @brief List of sensor types supported by the hub"]
#[doc = ""]
#[doc = " See the SH-2 Reference Manual for more information on each type."]
pub type sh2_SensorId_e = cty::c_uint;
pub type sh2_SensorId_t = u8;
#[doc = " @brief Sensor Configuration settings"]
#[doc = ""]
#[doc = " See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_SensorConfig {
    #[doc = "< @brief Enable reports on change"]
    pub changeSensitivityEnabled: bool,
    #[doc = "< @brief Change reports relative (vs absolute)"]
    pub changeSensitivityRelative: bool,
    #[doc = "< @brief Wake host on event"]
    pub wakeupEnabled: bool,
    #[doc = "< @brief Sensor remains on in sleep state"]
    pub alwaysOnEnabled: bool,
    #[doc = "< @brief Report-on-change threshold"]
    pub changeSensitivity: u16,
    #[doc = "< @brief [uS] Report interval"]
    pub reportInterval_us: u32,
    #[doc = "< @brief [uS] Batch interval"]
    pub batchInterval_us: u32,
    #[doc = "< @brief See SH-2 Reference Manual for details."]
    pub sensorSpecific: u32,
}
#[test]
fn bindgen_test_layout_sh2_SensorConfig() {
    assert_eq!(
        ::core::mem::size_of::<sh2_SensorConfig>(),
        20usize,
        concat!("Size of: ", stringify!(sh2_SensorConfig))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_SensorConfig>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_SensorConfig))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_SensorConfig>())).changeSensitivityEnabled as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorConfig),
            "::",
            stringify!(changeSensitivityEnabled)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_SensorConfig>())).changeSensitivityRelative as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorConfig),
            "::",
            stringify!(changeSensitivityRelative)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_SensorConfig>())).wakeupEnabled as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorConfig),
            "::",
            stringify!(wakeupEnabled)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_SensorConfig>())).alwaysOnEnabled as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorConfig),
            "::",
            stringify!(alwaysOnEnabled)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_SensorConfig>())).changeSensitivity as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorConfig),
            "::",
            stringify!(changeSensitivity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_SensorConfig>())).reportInterval_us as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorConfig),
            "::",
            stringify!(reportInterval_us)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_SensorConfig>())).batchInterval_us as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorConfig),
            "::",
            stringify!(batchInterval_us)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_SensorConfig>())).sensorSpecific as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorConfig),
            "::",
            stringify!(sensorSpecific)
        )
    );
}
pub type sh2_SensorConfig_t = sh2_SensorConfig;
#[doc = " @brief Sensor Metadata Record"]
#[doc = ""]
#[doc = " See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_SensorMetadata {
    #[doc = "< @brief Motion Engine Version"]
    pub meVersion: u8,
    #[doc = "< @brief Motion Hub Version"]
    pub mhVersion: u8,
    #[doc = "< @brief SensorHub Version"]
    pub shVersion: u8,
    #[doc = "< @brief Same units as sensor reports"]
    pub range: u32,
    #[doc = "< @brief Same units as sensor reports"]
    pub resolution: u32,
    #[doc = "< @brief Metadata record format revision"]
    pub revision: u16,
    #[doc = "< @brief [mA] Fixed point 16Q10 format"]
    pub power_mA: u16,
    #[doc = "< @brief [uS]"]
    pub minPeriod_uS: u32,
    #[doc = "< @brief [uS]"]
    pub maxPeriod_uS: u32,
    #[doc = "< @brief (Unused)"]
    pub fifoReserved: u32,
    #[doc = "< @brief (Unused)"]
    pub fifoMax: u32,
    #[doc = "< @brief (Unused)"]
    pub batchBufferBytes: u32,
    #[doc = "< @brief q point for sensor values"]
    pub qPoint1: u16,
    #[doc = "< @brief q point for accuracy or bias fields"]
    pub qPoint2: u16,
    #[doc = "< @brief q point for sensor data change sensitivity"]
    pub qPoint3: u16,
    #[doc = "< @brief [bytes]"]
    pub vendorIdLen: u32,
    #[doc = "< @brief Vendor name and part number"]
    pub vendorId: [cty::c_char; 48usize],
    #[doc = "< @brief [bytes]"]
    pub sensorSpecificLen: u32,
    #[doc = "< @brief See SH-2 Reference Manual"]
    pub sensorSpecific: [u8; 48usize],
}
#[test]
fn bindgen_test_layout_sh2_SensorMetadata() {
    assert_eq!(
        ::core::mem::size_of::<sh2_SensorMetadata>(),
        148usize,
        concat!("Size of: ", stringify!(sh2_SensorMetadata))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_SensorMetadata>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_SensorMetadata))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_SensorMetadata>())).meVersion as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorMetadata),
            "::",
            stringify!(meVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_SensorMetadata>())).mhVersion as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorMetadata),
            "::",
            stringify!(mhVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_SensorMetadata>())).shVersion as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorMetadata),
            "::",
            stringify!(shVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_SensorMetadata>())).range as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorMetadata),
            "::",
            stringify!(range)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_SensorMetadata>())).resolution as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorMetadata),
            "::",
            stringify!(resolution)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_SensorMetadata>())).revision as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorMetadata),
            "::",
            stringify!(revision)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_SensorMetadata>())).power_mA as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorMetadata),
            "::",
            stringify!(power_mA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_SensorMetadata>())).minPeriod_uS as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorMetadata),
            "::",
            stringify!(minPeriod_uS)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_SensorMetadata>())).maxPeriod_uS as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorMetadata),
            "::",
            stringify!(maxPeriod_uS)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_SensorMetadata>())).fifoReserved as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorMetadata),
            "::",
            stringify!(fifoReserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_SensorMetadata>())).fifoMax as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorMetadata),
            "::",
            stringify!(fifoMax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_SensorMetadata>())).batchBufferBytes as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorMetadata),
            "::",
            stringify!(batchBufferBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_SensorMetadata>())).qPoint1 as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorMetadata),
            "::",
            stringify!(qPoint1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_SensorMetadata>())).qPoint2 as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorMetadata),
            "::",
            stringify!(qPoint2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_SensorMetadata>())).qPoint3 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorMetadata),
            "::",
            stringify!(qPoint3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_SensorMetadata>())).vendorIdLen as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorMetadata),
            "::",
            stringify!(vendorIdLen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_SensorMetadata>())).vendorId as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorMetadata),
            "::",
            stringify!(vendorId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_SensorMetadata>())).sensorSpecificLen as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorMetadata),
            "::",
            stringify!(sensorSpecificLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_SensorMetadata>())).sensorSpecific as *const _ as usize
        },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorMetadata),
            "::",
            stringify!(sensorSpecific)
        )
    );
}
pub type sh2_SensorMetadata_t = sh2_SensorMetadata;
#[doc = " @brief SensorHub Error Record"]
#[doc = ""]
#[doc = " See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_ErrorRecord {
    #[doc = "< @brief Error severity, 0: most severe."]
    pub severity: u8,
    #[doc = "< @brief Sequence number (by severity)"]
    pub sequence: u8,
    #[doc = "< @brief 1-MotionEngine, 2-MotionHub, 3-SensorHub, 4-Chip"]
    pub source: u8,
    #[doc = "< @brief See SH-2 Reference Manual"]
    pub error: u8,
    #[doc = "< @brief See SH-2 Reference Manual"]
    pub module: u8,
    #[doc = "< @brief See SH-2 Reference Manual"]
    pub code: u8,
}
#[test]
fn bindgen_test_layout_sh2_ErrorRecord() {
    assert_eq!(
        ::core::mem::size_of::<sh2_ErrorRecord>(),
        6usize,
        concat!("Size of: ", stringify!(sh2_ErrorRecord))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_ErrorRecord>(),
        1usize,
        concat!("Alignment of ", stringify!(sh2_ErrorRecord))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_ErrorRecord>())).severity as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_ErrorRecord),
            "::",
            stringify!(severity)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_ErrorRecord>())).sequence as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_ErrorRecord),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_ErrorRecord>())).source as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_ErrorRecord),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_ErrorRecord>())).error as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_ErrorRecord),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_ErrorRecord>())).module as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_ErrorRecord),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_ErrorRecord>())).code as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_ErrorRecord),
            "::",
            stringify!(code)
        )
    );
}
pub type sh2_ErrorRecord_t = sh2_ErrorRecord;
#[doc = " @brief SensorHub Counter Record"]
#[doc = ""]
#[doc = " See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_Counts {
    #[doc = "< @brief [events]"]
    pub offered: u32,
    #[doc = "< @brief [events]"]
    pub accepted: u32,
    #[doc = "< @brief [events]"]
    pub on: u32,
    #[doc = "< @brief [events]"]
    pub attempted: u32,
}
#[test]
fn bindgen_test_layout_sh2_Counts() {
    assert_eq!(
        ::core::mem::size_of::<sh2_Counts>(),
        16usize,
        concat!("Size of: ", stringify!(sh2_Counts))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_Counts>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_Counts))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_Counts>())).offered as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_Counts),
            "::",
            stringify!(offered)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_Counts>())).accepted as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_Counts),
            "::",
            stringify!(accepted)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_Counts>())).on as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_Counts),
            "::",
            stringify!(on)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_Counts>())).attempted as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_Counts),
            "::",
            stringify!(attempted)
        )
    );
}
pub type sh2_Counts_t = sh2_Counts;
#[doc = "< @brief Use Rotation Vector"]
pub const sh2_TareBasis_SH2_TARE_BASIS_ROTATION_VECTOR: sh2_TareBasis = 0;
#[doc = "< @brief Use Game Rotation Vector"]
pub const sh2_TareBasis_SH2_TARE_BASIS_GAMING_ROTATION_VECTOR: sh2_TareBasis = 1;
#[doc = "< @brief Use Geomagnetic R.V."]
pub const sh2_TareBasis_SH2_TARE_BASIS_GEOMAGNETIC_ROTATION_VECTOR: sh2_TareBasis = 2;
#[doc = " @brief Values for specifying tare basis"]
#[doc = ""]
#[doc = " See the SH-2 Reference Manual for more detail."]
pub type sh2_TareBasis = cty::c_uint;
pub use self::sh2_TareBasis as sh2_TareBasis_t;
#[doc = "< @brief sh2_tareNow() axes bit field"]
pub const sh2_TareAxis_SH2_TARE_X: sh2_TareAxis = 1;
#[doc = "< @brief sh2_tareNow() axes bit field"]
pub const sh2_TareAxis_SH2_TARE_Y: sh2_TareAxis = 2;
#[doc = "< @brief sh2_tareNow() axes bit field"]
pub const sh2_TareAxis_SH2_TARE_Z: sh2_TareAxis = 4;
#[doc = " @brief Bit Fields for specifying tare axes."]
#[doc = ""]
#[doc = " See the SH-2 Reference Manual for more detail."]
pub type sh2_TareAxis = cty::c_uint;
pub use self::sh2_TareAxis as sh2_TareAxis_t;
#[doc = " @brief Quaternion (double precision floating point representation.)"]
#[doc = ""]
#[doc = " See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_Quaternion {
    pub x: f64,
    pub y: f64,
    pub z: f64,
    pub w: f64,
}
#[test]
fn bindgen_test_layout_sh2_Quaternion() {
    assert_eq!(
        ::core::mem::size_of::<sh2_Quaternion>(),
        32usize,
        concat!("Size of: ", stringify!(sh2_Quaternion))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_Quaternion>(),
        8usize,
        concat!("Alignment of ", stringify!(sh2_Quaternion))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_Quaternion>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_Quaternion),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_Quaternion>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_Quaternion),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_Quaternion>())).z as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_Quaternion),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_Quaternion>())).w as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_Quaternion),
            "::",
            stringify!(w)
        )
    );
}
pub type sh2_Quaternion_t = sh2_Quaternion;
pub const sh2_OscType_t_SH2_OSC_INTERNAL: sh2_OscType_t = 0;
pub const sh2_OscType_t_SH2_OSC_EXT_CRYSTAL: sh2_OscType_t = 1;
pub const sh2_OscType_t_SH2_OSC_EXT_CLOCK: sh2_OscType_t = 2;
#[doc = " @brief Oscillator type: Internal or External"]
#[doc = ""]
#[doc = " See the SH-2 Reference Manual for more detail."]
pub type sh2_OscType_t = cty::c_uint;
pub const sh2_CalStatus_t_SH2_CAL_SUCCESS: sh2_CalStatus_t = 0;
pub const sh2_CalStatus_t_SH2_CAL_NO_ZRO: sh2_CalStatus_t = 1;
pub const sh2_CalStatus_t_SH2_CAL_NO_STATIONARY_DETECTION: sh2_CalStatus_t = 2;
pub const sh2_CalStatus_t_SH2_CAL_ROTATION_OUTSIDE_SPEC: sh2_CalStatus_t = 3;
pub const sh2_CalStatus_t_SH2_CAL_ZRO_OUTSIDE_SPEC: sh2_CalStatus_t = 4;
pub const sh2_CalStatus_t_SH2_CAL_ZGO_OUTSIDE_SPEC: sh2_CalStatus_t = 5;
pub const sh2_CalStatus_t_SH2_CAL_GYRO_GAIN_OUTSIDE_SPEC: sh2_CalStatus_t = 6;
pub const sh2_CalStatus_t_SH2_CAL_GYRO_PERIOD_OUTSIDE_SPEC: sh2_CalStatus_t = 7;
pub const sh2_CalStatus_t_SH2_CAL_GYRO_DROPS_OUTSIDE_SPEC: sh2_CalStatus_t = 8;
#[doc = " @brief Calibration result"]
#[doc = ""]
#[doc = " See the SH-2 Reference Manual, Finish Calibration Response."]
pub type sh2_CalStatus_t = cty::c_uint;
pub const sh2_IZroMotionIntent_t_SH2_IZRO_MI_UNKNOWN: sh2_IZroMotionIntent_t = 0;
pub const sh2_IZroMotionIntent_t_SH2_IZRO_MI_STATIONARY_NO_VIBRATION: sh2_IZroMotionIntent_t = 1;
pub const sh2_IZroMotionIntent_t_SH2_IZRO_MI_STATIONARY_WITH_VIBRATION: sh2_IZroMotionIntent_t = 2;
pub const sh2_IZroMotionIntent_t_SH2_IZRO_MI_IN_MOTION: sh2_IZroMotionIntent_t = 3;
#[doc = " @brief Interactive ZRO Motion Intent"]
#[doc = ""]
#[doc = " See the SH-2 Reference Manual, 6.4.13"]
pub type sh2_IZroMotionIntent_t = cty::c_uint;
pub const sh2_IZroMotionRequest_t_SH2_IZRO_MR_NO_REQUEST: sh2_IZroMotionRequest_t = 0;
pub const sh2_IZroMotionRequest_t_SH2_IZRO_MR_STAY_STATIONARY: sh2_IZroMotionRequest_t = 1;
pub const sh2_IZroMotionRequest_t_SH2_IZRO_MR_STATIONARY_NON_URGENT: sh2_IZroMotionRequest_t = 2;
pub const sh2_IZroMotionRequest_t_SH2_IZRO_MR_STATIONARY_URGENT: sh2_IZroMotionRequest_t = 3;
#[doc = " @brief Interactive ZRO Motion Intent"]
#[doc = ""]
#[doc = " See the SH-2 Reference Manual, 6.4.13"]
pub type sh2_IZroMotionRequest_t = cty::c_uint;
pub const sh2_AsyncEventId_e_SH2_RESET: sh2_AsyncEventId_e = 0;
pub const sh2_AsyncEventId_e_SH2_SHTP_EVENT: sh2_AsyncEventId_e = 1;
pub const sh2_AsyncEventId_e_SH2_GET_FEATURE_RESP: sh2_AsyncEventId_e = 2;
#[doc = " @brief Asynchronous Event"]
#[doc = ""]
#[doc = " Represents reset events and other non-sensor events received from SH-2 sensor hub."]
pub type sh2_AsyncEventId_e = cty::c_uint;
pub use self::sh2_AsyncEventId_e as sh2_AsyncEventId_t;
pub const sh2_ShtpEvent_e_SH2_SHTP_TX_DISCARD: sh2_ShtpEvent_e = 0;
pub const sh2_ShtpEvent_e_SH2_SHTP_SHORT_FRAGMENT: sh2_ShtpEvent_e = 1;
pub const sh2_ShtpEvent_e_SH2_SHTP_TOO_LARGE_PAYLOADS: sh2_ShtpEvent_e = 2;
pub const sh2_ShtpEvent_e_SH2_SHTP_BAD_RX_CHAN: sh2_ShtpEvent_e = 3;
pub const sh2_ShtpEvent_e_SH2_SHTP_BAD_TX_CHAN: sh2_ShtpEvent_e = 4;
pub type sh2_ShtpEvent_e = cty::c_uint;
pub type sh2_ShtpEvent_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_SensorConfigResp_e {
    pub sensorId: sh2_SensorId_t,
    pub sensorConfig: sh2_SensorConfig_t,
}
#[test]
fn bindgen_test_layout_sh2_SensorConfigResp_e() {
    assert_eq!(
        ::core::mem::size_of::<sh2_SensorConfigResp_e>(),
        24usize,
        concat!("Size of: ", stringify!(sh2_SensorConfigResp_e))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_SensorConfigResp_e>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_SensorConfigResp_e))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_SensorConfigResp_e>())).sensorId as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorConfigResp_e),
            "::",
            stringify!(sensorId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_SensorConfigResp_e>())).sensorConfig as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorConfigResp_e),
            "::",
            stringify!(sensorConfig)
        )
    );
}
pub type sh2_SensorConfigResp_t = sh2_SensorConfigResp_e;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sh2_AsyncEvent {
    pub eventId: u32,
    pub __bindgen_anon_1: sh2_AsyncEvent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sh2_AsyncEvent__bindgen_ty_1 {
    pub shtpEvent: sh2_ShtpEvent_t,
    pub sh2SensorConfigResp: sh2_SensorConfigResp_t,
}
#[test]
fn bindgen_test_layout_sh2_AsyncEvent__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<sh2_AsyncEvent__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(sh2_AsyncEvent__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_AsyncEvent__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_AsyncEvent__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_AsyncEvent__bindgen_ty_1>())).shtpEvent as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_AsyncEvent__bindgen_ty_1),
            "::",
            stringify!(shtpEvent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_AsyncEvent__bindgen_ty_1>())).sh2SensorConfigResp
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_AsyncEvent__bindgen_ty_1),
            "::",
            stringify!(sh2SensorConfigResp)
        )
    );
}
#[test]
fn bindgen_test_layout_sh2_AsyncEvent() {
    assert_eq!(
        ::core::mem::size_of::<sh2_AsyncEvent>(),
        28usize,
        concat!("Size of: ", stringify!(sh2_AsyncEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_AsyncEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_AsyncEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_AsyncEvent>())).eventId as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_AsyncEvent),
            "::",
            stringify!(eventId)
        )
    );
}
pub type sh2_AsyncEvent_t = sh2_AsyncEvent;
pub type sh2_EventCallback_t = ::core::option::Option<
    unsafe extern "C" fn(cookie: *mut cty::c_void, pEvent: *mut sh2_AsyncEvent_t),
>;
extern "C" {
    #[doc = " @brief Open a session with a sensor hub."]
    #[doc = ""]
    #[doc = " This function should be called before others in this API."]
    #[doc = " An instance of an SH2 HAL should be passed in."]
    #[doc = " This call will result in the open() function of the HAL being called."]
    #[doc = ""]
    #[doc = " As part of the initialization process, a callback function is registered that will"]
    #[doc = " be invoked when the device generates certain events.  (See sh2_AsyncEventId)"]
    #[doc = ""]
    #[doc = " @param pHal Pointer to an SH2 HAL instance, provided by the target system."]
    #[doc = " @param  eventCallback Will be called when events, such as reset complete, occur."]
    #[doc = " @param  eventCookie Will be passed to eventCallback."]
    #[doc = " @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_open(
        pHal: *mut sh2_Hal_t,
        eventCallback: sh2_EventCallback_t,
        eventCookie: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Close a session with a sensor hub."]
    #[doc = ""]
    #[doc = " This should be called at the end of a sensor hub session."]
    #[doc = " The underlying SHTP and HAL instances will be closed."]
    #[doc = ""]
    pub fn sh2_close();
}
extern "C" {
    #[doc = " @brief Service the SH2 device, reading any data that is available and dispatching callbacks."]
    #[doc = ""]
    #[doc = " This function should be called periodically by the host system to service an open sensor hub."]
    #[doc = ""]
    pub fn sh2_service();
}
extern "C" {
    #[doc = " @brief Register a function to receive sensor events."]
    #[doc = ""]
    #[doc = " @param  callback A function that will be called each time a sensor event is received."]
    #[doc = " @param  cookie  A value that will be passed to the sensor callback function."]
    #[doc = " @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_setSensorCallback(
        callback: sh2_SensorCallback_t,
        cookie: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Reset the sensor hub device by sending RESET (1) command on \"device\" channel."]
    #[doc = ""]
    #[doc = " @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_devReset() -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Turn sensor hub on by sending ON (2) command on \"device\" channel."]
    #[doc = ""]
    #[doc = " @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_devOn() -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Put sensor hub in sleep state by sending SLEEP (3) command on \"device\" channel."]
    #[doc = ""]
    #[doc = " @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_devSleep() -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Get Product ID information from Sensorhub."]
    #[doc = ""]
    #[doc = " @param  prodIds Pointer to structure that will receive results."]
    #[doc = " @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_getProdIds(prodIds: *mut sh2_ProductIds_t) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Get sensor configuration."]
    #[doc = ""]
    #[doc = " @param  sensorId Which sensor to query."]
    #[doc = " @param  config SensorConfig structure to store results."]
    #[doc = " @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_getSensorConfig(
        sensorId: sh2_SensorId_t,
        config: *mut sh2_SensorConfig_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Set sensor configuration. (e.g enable a sensor at a particular rate.)"]
    #[doc = ""]
    #[doc = " @param  sensorId Which sensor to configure."]
    #[doc = " @param  pConfig Pointer to structure holding sensor configuration."]
    #[doc = " @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_setSensorConfig(
        sensorId: sh2_SensorId_t,
        pConfig: *const sh2_SensorConfig_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Get metadata related to a sensor."]
    #[doc = ""]
    #[doc = " @param  sensorId Which sensor to query."]
    #[doc = " @param  pData Pointer to structure to receive the results."]
    #[doc = " @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_getMetadata(
        sensorId: sh2_SensorId_t,
        pData: *mut sh2_SensorMetadata_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Get an FRS record."]
    #[doc = ""]
    #[doc = " @param  recordId Which FRS Record to retrieve."]
    #[doc = " @param  pData pointer to buffer to receive the results"]
    #[doc = " @param[in] words Size of pData buffer, in 32-bit words."]
    #[doc = " @param[out] words Number of 32-bit words retrieved."]
    #[doc = " @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_getFrs(recordId: u16, pData: *mut u32, words: *mut u16) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Set an FRS record"]
    #[doc = ""]
    #[doc = " @param  recordId Which FRS Record to set."]
    #[doc = " @param  pData pointer to buffer containing the new data."]
    #[doc = " @param  words number of 32-bit words to write.  (0 to delete record.)"]
    #[doc = " @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_setFrs(recordId: u16, pData: *mut u32, words: u16) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Get error counts."]
    #[doc = ""]
    #[doc = " @param  severity Only errors of this severity or greater are returned."]
    #[doc = " @param  pErrors Buffer to receive error codes."]
    #[doc = " @param  numErrors size of pErrors array"]
    #[doc = " @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_getErrors(
        severity: u8,
        pErrors: *mut sh2_ErrorRecord_t,
        numErrors: *mut u16,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Read counters related to a sensor."]
    #[doc = ""]
    #[doc = " @param  sensorId Which sensor to operate on."]
    #[doc = " @param  pCounts Pointer to Counts structure that will receive data."]
    #[doc = " @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_getCounts(sensorId: sh2_SensorId_t, pCounts: *mut sh2_Counts_t) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Clear counters related to a sensor."]
    #[doc = ""]
    #[doc = " @param  sensorId which sensor to operate on."]
    #[doc = " @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_clearCounts(sensorId: sh2_SensorId_t) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Perform a tare operation on one or more axes."]
    #[doc = ""]
    #[doc = " @param  axes Bit mask specifying which axes should be tared."]
    #[doc = " @param  basis Which rotation vector to use as the basis for Tare adjustment."]
    #[doc = " @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_setTareNow(axes: u8, basis: sh2_TareBasis_t) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Clears the previously applied tare operation."]
    #[doc = ""]
    #[doc = " @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_clearTare() -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Persist the results of last tare operation to flash."]
    #[doc = ""]
    #[doc = " @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_persistTare() -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Set the current run-time sensor reorientation. (Set to zero to clear tare.)"]
    #[doc = ""]
    #[doc = " @param  orientation Quaternion rotation vector to apply as new tare."]
    #[doc = " @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_setReorientation(orientation: *mut sh2_Quaternion_t) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Command the sensorhub to reset."]
    #[doc = ""]
    #[doc = " @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_reinitialize() -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Save Dynamic Calibration Data to flash."]
    #[doc = ""]
    #[doc = " @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_saveDcdNow() -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Get Oscillator type."]
    #[doc = ""]
    #[doc = " @param  pOscType pointer to data structure to receive results."]
    #[doc = " @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_getOscType(pOscType: *mut sh2_OscType_t) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Enable/Disable dynamic calibration for certain sensors"]
    #[doc = ""]
    #[doc = " @param  sensors Bit mask to configure which sensors are affected."]
    #[doc = " @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_setCalConfig(sensors: u8) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Get dynamic calibration configuration settings."]
    #[doc = ""]
    #[doc = " @param  pSensors pointer to Bit mask, set on return."]
    #[doc = " @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_getCalConfig(pSensors: *mut u8) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Configure automatic saving of dynamic calibration data."]
    #[doc = ""]
    #[doc = " @param  enabled Enable or Disable DCD auto-save."]
    #[doc = " @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_setDcdAutoSave(enabled: bool) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Immediately issue all buffered sensor reports from a given sensor."]
    #[doc = ""]
    #[doc = " @param  sensorId Which sensor reports to flush."]
    #[doc = " @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_flush(sensorId: sh2_SensorId_t) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Command clear DCD in RAM, then reset sensor hub."]
    #[doc = ""]
    #[doc = " @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_clearDcdAndReset() -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Start simple self-calibration procedure."]
    #[doc = ""]
    #[doc = " @parameter interval_us sensor report interval, uS."]
    #[doc = " @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_startCal(interval_us: u32) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Finish simple self-calibration procedure."]
    #[doc = ""]
    #[doc = " @parameter status contains calibration status code on return."]
    #[doc = " @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_finishCal(status: *mut sh2_CalStatus_t) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief send Interactive ZRO Request."]
    #[doc = ""]
    #[doc = " @parameter intent Inform the sensor hub what sort of motion should be in progress."]
    #[doc = " @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_setIZro(intent: sh2_IZroMotionIntent_t) -> cty::c_int;
}
#[doc = " @brief Raw Accelerometer"]
#[doc = ""]
#[doc = " See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_RawAccelerometer {
    #[doc = "< @brief [ADC counts]"]
    pub x: i16,
    #[doc = "< @brief [ADC counts]"]
    pub y: i16,
    #[doc = "< @brief [ADC counts]"]
    pub z: i16,
    #[doc = "< @brief [uS]"]
    pub timestamp: u32,
}
#[test]
fn bindgen_test_layout_sh2_RawAccelerometer() {
    assert_eq!(
        ::core::mem::size_of::<sh2_RawAccelerometer>(),
        12usize,
        concat!("Size of: ", stringify!(sh2_RawAccelerometer))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_RawAccelerometer>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_RawAccelerometer))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_RawAccelerometer>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RawAccelerometer),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_RawAccelerometer>())).y as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RawAccelerometer),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_RawAccelerometer>())).z as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RawAccelerometer),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_RawAccelerometer>())).timestamp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RawAccelerometer),
            "::",
            stringify!(timestamp)
        )
    );
}
pub type sh2_RawAccelerometer_t = sh2_RawAccelerometer;
#[doc = " @brief Accelerometer"]
#[doc = ""]
#[doc = " See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_Accelerometer {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[test]
fn bindgen_test_layout_sh2_Accelerometer() {
    assert_eq!(
        ::core::mem::size_of::<sh2_Accelerometer>(),
        12usize,
        concat!("Size of: ", stringify!(sh2_Accelerometer))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_Accelerometer>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_Accelerometer))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_Accelerometer>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_Accelerometer),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_Accelerometer>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_Accelerometer),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_Accelerometer>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_Accelerometer),
            "::",
            stringify!(z)
        )
    );
}
pub type sh2_Accelerometer_t = sh2_Accelerometer;
#[doc = " @brief Raw gyroscope"]
#[doc = ""]
#[doc = " See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_RawGyroscope {
    #[doc = "< @brief [ADC Counts]"]
    pub x: i16,
    #[doc = "< @brief [ADC Counts]"]
    pub y: i16,
    #[doc = "< @brief [ADC Counts]"]
    pub z: i16,
    #[doc = "< @brief [ADC Counts]"]
    pub temperature: i16,
    #[doc = "< @brief [uS]"]
    pub timestamp: u32,
}
#[test]
fn bindgen_test_layout_sh2_RawGyroscope() {
    assert_eq!(
        ::core::mem::size_of::<sh2_RawGyroscope>(),
        12usize,
        concat!("Size of: ", stringify!(sh2_RawGyroscope))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_RawGyroscope>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_RawGyroscope))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_RawGyroscope>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RawGyroscope),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_RawGyroscope>())).y as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RawGyroscope),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_RawGyroscope>())).z as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RawGyroscope),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_RawGyroscope>())).temperature as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RawGyroscope),
            "::",
            stringify!(temperature)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_RawGyroscope>())).timestamp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RawGyroscope),
            "::",
            stringify!(timestamp)
        )
    );
}
pub type sh2_RawGyroscope_t = sh2_RawGyroscope;
#[doc = " @brief Gyroscope"]
#[doc = ""]
#[doc = " See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_Gyroscope {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[test]
fn bindgen_test_layout_sh2_Gyroscope() {
    assert_eq!(
        ::core::mem::size_of::<sh2_Gyroscope>(),
        12usize,
        concat!("Size of: ", stringify!(sh2_Gyroscope))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_Gyroscope>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_Gyroscope))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_Gyroscope>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_Gyroscope),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_Gyroscope>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_Gyroscope),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_Gyroscope>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_Gyroscope),
            "::",
            stringify!(z)
        )
    );
}
pub type sh2_Gyroscope_t = sh2_Gyroscope;
#[doc = " @brief Uncalibrated gyroscope"]
#[doc = ""]
#[doc = " See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_GyroscopeUncalibrated {
    #[doc = "< @brief [rad/s]"]
    pub x: f32,
    #[doc = "< @brief [rad/s]"]
    pub y: f32,
    #[doc = "< @brief [rad/s]"]
    pub z: f32,
    #[doc = "< @brief [rad/s]"]
    pub biasX: f32,
    #[doc = "< @brief [rad/s]"]
    pub biasY: f32,
    #[doc = "< @brief [rad/s]"]
    pub biasZ: f32,
}
#[test]
fn bindgen_test_layout_sh2_GyroscopeUncalibrated() {
    assert_eq!(
        ::core::mem::size_of::<sh2_GyroscopeUncalibrated>(),
        24usize,
        concat!("Size of: ", stringify!(sh2_GyroscopeUncalibrated))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_GyroscopeUncalibrated>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_GyroscopeUncalibrated))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_GyroscopeUncalibrated>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_GyroscopeUncalibrated),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_GyroscopeUncalibrated>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_GyroscopeUncalibrated),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_GyroscopeUncalibrated>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_GyroscopeUncalibrated),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_GyroscopeUncalibrated>())).biasX as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_GyroscopeUncalibrated),
            "::",
            stringify!(biasX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_GyroscopeUncalibrated>())).biasY as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_GyroscopeUncalibrated),
            "::",
            stringify!(biasY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_GyroscopeUncalibrated>())).biasZ as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_GyroscopeUncalibrated),
            "::",
            stringify!(biasZ)
        )
    );
}
pub type sh2_GyroscopeUncalibrated_t = sh2_GyroscopeUncalibrated;
#[doc = " @brief Raw Magnetometer"]
#[doc = ""]
#[doc = " See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_RawMagnetometer {
    #[doc = "< @brief [ADC Counts]"]
    pub x: i16,
    #[doc = "< @brief [ADC Counts]"]
    pub y: i16,
    #[doc = "< @brief [ADC Counts]"]
    pub z: i16,
    #[doc = "< @brief [uS]"]
    pub timestamp: u32,
}
#[test]
fn bindgen_test_layout_sh2_RawMagnetometer() {
    assert_eq!(
        ::core::mem::size_of::<sh2_RawMagnetometer>(),
        12usize,
        concat!("Size of: ", stringify!(sh2_RawMagnetometer))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_RawMagnetometer>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_RawMagnetometer))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_RawMagnetometer>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RawMagnetometer),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_RawMagnetometer>())).y as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RawMagnetometer),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_RawMagnetometer>())).z as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RawMagnetometer),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_RawMagnetometer>())).timestamp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RawMagnetometer),
            "::",
            stringify!(timestamp)
        )
    );
}
pub type sh2_RawMagnetometer_t = sh2_RawMagnetometer;
#[doc = " @brief Magnetic field"]
#[doc = ""]
#[doc = " See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_MagneticField {
    #[doc = "< @brief [uTesla]"]
    pub x: f32,
    #[doc = "< @brief [uTesla]"]
    pub y: f32,
    #[doc = "< @brief [uTesla]"]
    pub z: f32,
}
#[test]
fn bindgen_test_layout_sh2_MagneticField() {
    assert_eq!(
        ::core::mem::size_of::<sh2_MagneticField>(),
        12usize,
        concat!("Size of: ", stringify!(sh2_MagneticField))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_MagneticField>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_MagneticField))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_MagneticField>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_MagneticField),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_MagneticField>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_MagneticField),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_MagneticField>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_MagneticField),
            "::",
            stringify!(z)
        )
    );
}
pub type sh2_MagneticField_t = sh2_MagneticField;
#[doc = " @brief Uncalibrated magnetic field"]
#[doc = ""]
#[doc = " See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_MagneticFieldUncalibrated {
    #[doc = "< @brief [uTesla]"]
    pub x: f32,
    #[doc = "< @brief [uTesla]"]
    pub y: f32,
    #[doc = "< @brief [uTesla]"]
    pub z: f32,
    #[doc = "< @brief [uTesla]"]
    pub biasX: f32,
    #[doc = "< @brief [uTesla]"]
    pub biasY: f32,
    #[doc = "< @brief [uTesla]"]
    pub biasZ: f32,
}
#[test]
fn bindgen_test_layout_sh2_MagneticFieldUncalibrated() {
    assert_eq!(
        ::core::mem::size_of::<sh2_MagneticFieldUncalibrated>(),
        24usize,
        concat!("Size of: ", stringify!(sh2_MagneticFieldUncalibrated))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_MagneticFieldUncalibrated>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_MagneticFieldUncalibrated))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_MagneticFieldUncalibrated>())).x as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_MagneticFieldUncalibrated),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_MagneticFieldUncalibrated>())).y as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_MagneticFieldUncalibrated),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_MagneticFieldUncalibrated>())).z as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_MagneticFieldUncalibrated),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_MagneticFieldUncalibrated>())).biasX as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_MagneticFieldUncalibrated),
            "::",
            stringify!(biasX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_MagneticFieldUncalibrated>())).biasY as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_MagneticFieldUncalibrated),
            "::",
            stringify!(biasY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_MagneticFieldUncalibrated>())).biasZ as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_MagneticFieldUncalibrated),
            "::",
            stringify!(biasZ)
        )
    );
}
pub type sh2_MagneticFieldUncalibrated_t = sh2_MagneticFieldUncalibrated;
#[doc = " @brief Rotation Vector with Accuracy"]
#[doc = ""]
#[doc = " See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_RotationVectorWAcc {
    #[doc = "< @brief Quaternion component i"]
    pub i: f32,
    #[doc = "< @brief Quaternion component j"]
    pub j: f32,
    #[doc = "< @brief Quaternion component k"]
    pub k: f32,
    #[doc = "< @brief Quaternion component, real"]
    pub real: f32,
    #[doc = "< @brief Accuracy estimate [radians]"]
    pub accuracy: f32,
}
#[test]
fn bindgen_test_layout_sh2_RotationVectorWAcc() {
    assert_eq!(
        ::core::mem::size_of::<sh2_RotationVectorWAcc>(),
        20usize,
        concat!("Size of: ", stringify!(sh2_RotationVectorWAcc))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_RotationVectorWAcc>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_RotationVectorWAcc))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_RotationVectorWAcc>())).i as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RotationVectorWAcc),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_RotationVectorWAcc>())).j as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RotationVectorWAcc),
            "::",
            stringify!(j)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_RotationVectorWAcc>())).k as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RotationVectorWAcc),
            "::",
            stringify!(k)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_RotationVectorWAcc>())).real as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RotationVectorWAcc),
            "::",
            stringify!(real)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_RotationVectorWAcc>())).accuracy as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RotationVectorWAcc),
            "::",
            stringify!(accuracy)
        )
    );
}
pub type sh2_RotationVectorWAcc_t = sh2_RotationVectorWAcc;
#[doc = " @brief Rotation Vector"]
#[doc = ""]
#[doc = " See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_RotationVector {
    #[doc = "< @brief Quaternion component i"]
    pub i: f32,
    #[doc = "< @brief Quaternion component j"]
    pub j: f32,
    #[doc = "< @brief Quaternion component k"]
    pub k: f32,
    #[doc = "< @brief Quaternion component real"]
    pub real: f32,
}
#[test]
fn bindgen_test_layout_sh2_RotationVector() {
    assert_eq!(
        ::core::mem::size_of::<sh2_RotationVector>(),
        16usize,
        concat!("Size of: ", stringify!(sh2_RotationVector))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_RotationVector>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_RotationVector))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_RotationVector>())).i as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RotationVector),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_RotationVector>())).j as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RotationVector),
            "::",
            stringify!(j)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_RotationVector>())).k as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RotationVector),
            "::",
            stringify!(k)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_RotationVector>())).real as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RotationVector),
            "::",
            stringify!(real)
        )
    );
}
pub type sh2_RotationVector_t = sh2_RotationVector;
#[doc = " @brief Atmospheric Pressure"]
#[doc = ""]
#[doc = " See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_Pressure {
    #[doc = "< @brief Atmospheric Pressure.  [hectopascals]"]
    pub value: f32,
}
#[test]
fn bindgen_test_layout_sh2_Pressure() {
    assert_eq!(
        ::core::mem::size_of::<sh2_Pressure>(),
        4usize,
        concat!("Size of: ", stringify!(sh2_Pressure))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_Pressure>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_Pressure))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_Pressure>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_Pressure),
            "::",
            stringify!(value)
        )
    );
}
pub type sh2_Pressure_t = sh2_Pressure;
#[doc = " @brief Ambient Light"]
#[doc = ""]
#[doc = " See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_AmbientLight {
    #[doc = "< @brief Ambient Light.  [lux]"]
    pub value: f32,
}
#[test]
fn bindgen_test_layout_sh2_AmbientLight() {
    assert_eq!(
        ::core::mem::size_of::<sh2_AmbientLight>(),
        4usize,
        concat!("Size of: ", stringify!(sh2_AmbientLight))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_AmbientLight>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_AmbientLight))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_AmbientLight>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_AmbientLight),
            "::",
            stringify!(value)
        )
    );
}
pub type sh2_AmbientLight_t = sh2_AmbientLight;
#[doc = " @brief Humidity"]
#[doc = ""]
#[doc = " See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_Humidity {
    #[doc = "< @brief Relative Humidity.  [percent]"]
    pub value: f32,
}
#[test]
fn bindgen_test_layout_sh2_Humidity() {
    assert_eq!(
        ::core::mem::size_of::<sh2_Humidity>(),
        4usize,
        concat!("Size of: ", stringify!(sh2_Humidity))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_Humidity>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_Humidity))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_Humidity>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_Humidity),
            "::",
            stringify!(value)
        )
    );
}
pub type sh2_Humidity_t = sh2_Humidity;
#[doc = " @brief Proximity"]
#[doc = ""]
#[doc = " See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_Proximity {
    #[doc = "< @brief Proximity.  [cm]"]
    pub value: f32,
}
#[test]
fn bindgen_test_layout_sh2_Proximity() {
    assert_eq!(
        ::core::mem::size_of::<sh2_Proximity>(),
        4usize,
        concat!("Size of: ", stringify!(sh2_Proximity))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_Proximity>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_Proximity))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_Proximity>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_Proximity),
            "::",
            stringify!(value)
        )
    );
}
pub type sh2_Proximity_t = sh2_Proximity;
#[doc = " @brief Temperature"]
#[doc = ""]
#[doc = " See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_Temperature {
    #[doc = "< @brief Temperature.  [C]"]
    pub value: f32,
}
#[test]
fn bindgen_test_layout_sh2_Temperature() {
    assert_eq!(
        ::core::mem::size_of::<sh2_Temperature>(),
        4usize,
        concat!("Size of: ", stringify!(sh2_Temperature))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_Temperature>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_Temperature))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_Temperature>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_Temperature),
            "::",
            stringify!(value)
        )
    );
}
pub type sh2_Temperature_t = sh2_Temperature;
#[doc = " @brief Reserved"]
#[doc = ""]
#[doc = " See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_Reserved {
    #[doc = "< @brief Reserved"]
    pub tbd: f32,
}
#[test]
fn bindgen_test_layout_sh2_Reserved() {
    assert_eq!(
        ::core::mem::size_of::<sh2_Reserved>(),
        4usize,
        concat!("Size of: ", stringify!(sh2_Reserved))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_Reserved>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_Reserved))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_Reserved>())).tbd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_Reserved),
            "::",
            stringify!(tbd)
        )
    );
}
pub type sh2_Reserved_t = sh2_Reserved;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_TapDetector {
    #[doc = "< @brief TapDetector."]
    pub flags: u8,
}
#[test]
fn bindgen_test_layout_sh2_TapDetector() {
    assert_eq!(
        ::core::mem::size_of::<sh2_TapDetector>(),
        1usize,
        concat!("Size of: ", stringify!(sh2_TapDetector))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_TapDetector>(),
        1usize,
        concat!("Alignment of ", stringify!(sh2_TapDetector))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_TapDetector>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_TapDetector),
            "::",
            stringify!(flags)
        )
    );
}
pub type sh2_TapDetector_t = sh2_TapDetector;
#[doc = " @brief StepDetector"]
#[doc = ""]
#[doc = " See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_StepDetector {
    #[doc = "< @brief Step detect latency [uS]."]
    pub latency: u32,
}
#[test]
fn bindgen_test_layout_sh2_StepDetector() {
    assert_eq!(
        ::core::mem::size_of::<sh2_StepDetector>(),
        4usize,
        concat!("Size of: ", stringify!(sh2_StepDetector))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_StepDetector>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_StepDetector))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_StepDetector>())).latency as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_StepDetector),
            "::",
            stringify!(latency)
        )
    );
}
pub type sh2_StepDetector_t = sh2_StepDetector;
#[doc = " @brief StepCounter"]
#[doc = ""]
#[doc = " See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_StepCounter {
    #[doc = "< @brief Step counter latency [uS]."]
    pub latency: u32,
    #[doc = "< @brief Steps counted."]
    pub steps: u16,
}
#[test]
fn bindgen_test_layout_sh2_StepCounter() {
    assert_eq!(
        ::core::mem::size_of::<sh2_StepCounter>(),
        8usize,
        concat!("Size of: ", stringify!(sh2_StepCounter))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_StepCounter>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_StepCounter))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_StepCounter>())).latency as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_StepCounter),
            "::",
            stringify!(latency)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_StepCounter>())).steps as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_StepCounter),
            "::",
            stringify!(steps)
        )
    );
}
pub type sh2_StepCounter_t = sh2_StepCounter;
#[doc = " @brief SigMotion"]
#[doc = ""]
#[doc = " See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_SigMotion {
    pub motion: u16,
}
#[test]
fn bindgen_test_layout_sh2_SigMotion() {
    assert_eq!(
        ::core::mem::size_of::<sh2_SigMotion>(),
        2usize,
        concat!("Size of: ", stringify!(sh2_SigMotion))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_SigMotion>(),
        2usize,
        concat!("Alignment of ", stringify!(sh2_SigMotion))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_SigMotion>())).motion as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SigMotion),
            "::",
            stringify!(motion)
        )
    );
}
pub type sh2_SigMotion_t = sh2_SigMotion;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_StabilityClassifier {
    pub classification: u8,
}
#[test]
fn bindgen_test_layout_sh2_StabilityClassifier() {
    assert_eq!(
        ::core::mem::size_of::<sh2_StabilityClassifier>(),
        1usize,
        concat!("Size of: ", stringify!(sh2_StabilityClassifier))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_StabilityClassifier>(),
        1usize,
        concat!("Alignment of ", stringify!(sh2_StabilityClassifier))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_StabilityClassifier>())).classification as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_StabilityClassifier),
            "::",
            stringify!(classification)
        )
    );
}
pub type sh2_StabilityClassifier_t = sh2_StabilityClassifier;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_ShakeDetector {
    pub shake: u16,
}
#[test]
fn bindgen_test_layout_sh2_ShakeDetector() {
    assert_eq!(
        ::core::mem::size_of::<sh2_ShakeDetector>(),
        2usize,
        concat!("Size of: ", stringify!(sh2_ShakeDetector))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_ShakeDetector>(),
        2usize,
        concat!("Alignment of ", stringify!(sh2_ShakeDetector))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_ShakeDetector>())).shake as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_ShakeDetector),
            "::",
            stringify!(shake)
        )
    );
}
pub type sh2_ShakeDetector_t = sh2_ShakeDetector;
#[doc = " @brief flipDetector"]
#[doc = ""]
#[doc = " See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_FlipDetector {
    pub flip: u16,
}
#[test]
fn bindgen_test_layout_sh2_FlipDetector() {
    assert_eq!(
        ::core::mem::size_of::<sh2_FlipDetector>(),
        2usize,
        concat!("Size of: ", stringify!(sh2_FlipDetector))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_FlipDetector>(),
        2usize,
        concat!("Alignment of ", stringify!(sh2_FlipDetector))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_FlipDetector>())).flip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_FlipDetector),
            "::",
            stringify!(flip)
        )
    );
}
pub type sh2_FlipDetector_t = sh2_FlipDetector;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_PickupDetector {
    #[doc = "< flag field with bits defined above."]
    pub pickup: u16,
}
#[test]
fn bindgen_test_layout_sh2_PickupDetector() {
    assert_eq!(
        ::core::mem::size_of::<sh2_PickupDetector>(),
        2usize,
        concat!("Size of: ", stringify!(sh2_PickupDetector))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_PickupDetector>(),
        2usize,
        concat!("Alignment of ", stringify!(sh2_PickupDetector))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_PickupDetector>())).pickup as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_PickupDetector),
            "::",
            stringify!(pickup)
        )
    );
}
pub type sh2_PickupDetector_t = sh2_PickupDetector;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_StabilityDetector {
    #[doc = "< flag field with bits defined above."]
    pub stability: u16,
}
#[test]
fn bindgen_test_layout_sh2_StabilityDetector() {
    assert_eq!(
        ::core::mem::size_of::<sh2_StabilityDetector>(),
        2usize,
        concat!("Size of: ", stringify!(sh2_StabilityDetector))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_StabilityDetector>(),
        2usize,
        concat!("Alignment of ", stringify!(sh2_StabilityDetector))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_StabilityDetector>())).stability as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_StabilityDetector),
            "::",
            stringify!(stability)
        )
    );
}
pub type sh2_StabilityDetector_t = sh2_StabilityDetector;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_PersonalActivityClassifier {
    pub page: u8,
    pub lastPage: bool,
    pub mostLikelyState: u8,
    pub confidence: [u8; 10usize],
}
#[test]
fn bindgen_test_layout_sh2_PersonalActivityClassifier() {
    assert_eq!(
        ::core::mem::size_of::<sh2_PersonalActivityClassifier>(),
        13usize,
        concat!("Size of: ", stringify!(sh2_PersonalActivityClassifier))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_PersonalActivityClassifier>(),
        1usize,
        concat!("Alignment of ", stringify!(sh2_PersonalActivityClassifier))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_PersonalActivityClassifier>())).page as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_PersonalActivityClassifier),
            "::",
            stringify!(page)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_PersonalActivityClassifier>())).lastPage as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_PersonalActivityClassifier),
            "::",
            stringify!(lastPage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_PersonalActivityClassifier>())).mostLikelyState as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_PersonalActivityClassifier),
            "::",
            stringify!(mostLikelyState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_PersonalActivityClassifier>())).confidence as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_PersonalActivityClassifier),
            "::",
            stringify!(confidence)
        )
    );
}
pub type sh2_PersonalActivityClassifier_t = sh2_PersonalActivityClassifier;
#[doc = " @brief sleepDetector"]
#[doc = ""]
#[doc = " See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_SleepDetector {
    pub sleepState: u8,
}
#[test]
fn bindgen_test_layout_sh2_SleepDetector() {
    assert_eq!(
        ::core::mem::size_of::<sh2_SleepDetector>(),
        1usize,
        concat!("Size of: ", stringify!(sh2_SleepDetector))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_SleepDetector>(),
        1usize,
        concat!("Alignment of ", stringify!(sh2_SleepDetector))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_SleepDetector>())).sleepState as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SleepDetector),
            "::",
            stringify!(sleepState)
        )
    );
}
pub type sh2_SleepDetector_t = sh2_SleepDetector;
#[doc = " @brief tiltDetector"]
#[doc = ""]
#[doc = " See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_TiltDetector {
    pub tilt: u16,
}
#[test]
fn bindgen_test_layout_sh2_TiltDetector() {
    assert_eq!(
        ::core::mem::size_of::<sh2_TiltDetector>(),
        2usize,
        concat!("Size of: ", stringify!(sh2_TiltDetector))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_TiltDetector>(),
        2usize,
        concat!("Alignment of ", stringify!(sh2_TiltDetector))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_TiltDetector>())).tilt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_TiltDetector),
            "::",
            stringify!(tilt)
        )
    );
}
pub type sh2_TiltDetector_t = sh2_TiltDetector;
#[doc = " @brief pocketDetector"]
#[doc = ""]
#[doc = " See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_PocketDetector {
    pub pocket: u16,
}
#[test]
fn bindgen_test_layout_sh2_PocketDetector() {
    assert_eq!(
        ::core::mem::size_of::<sh2_PocketDetector>(),
        2usize,
        concat!("Size of: ", stringify!(sh2_PocketDetector))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_PocketDetector>(),
        2usize,
        concat!("Alignment of ", stringify!(sh2_PocketDetector))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_PocketDetector>())).pocket as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_PocketDetector),
            "::",
            stringify!(pocket)
        )
    );
}
pub type sh2_PocketDetector_t = sh2_PocketDetector;
#[doc = " @brief circleDetector"]
#[doc = ""]
#[doc = " See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_CircleDetector {
    pub circle: u16,
}
#[test]
fn bindgen_test_layout_sh2_CircleDetector() {
    assert_eq!(
        ::core::mem::size_of::<sh2_CircleDetector>(),
        2usize,
        concat!("Size of: ", stringify!(sh2_CircleDetector))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_CircleDetector>(),
        2usize,
        concat!("Alignment of ", stringify!(sh2_CircleDetector))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_CircleDetector>())).circle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_CircleDetector),
            "::",
            stringify!(circle)
        )
    );
}
pub type sh2_CircleDetector_t = sh2_CircleDetector;
#[doc = " @brief heartRateMonitor"]
#[doc = ""]
#[doc = " See SH-2 Reference Manual for details."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_HeartRateMonitor {
    #[doc = "< heart rate in beats per minute."]
    pub heartRate: u16,
}
#[test]
fn bindgen_test_layout_sh2_HeartRateMonitor() {
    assert_eq!(
        ::core::mem::size_of::<sh2_HeartRateMonitor>(),
        2usize,
        concat!("Size of: ", stringify!(sh2_HeartRateMonitor))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_HeartRateMonitor>(),
        2usize,
        concat!("Alignment of ", stringify!(sh2_HeartRateMonitor))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_HeartRateMonitor>())).heartRate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_HeartRateMonitor),
            "::",
            stringify!(heartRate)
        )
    );
}
pub type sh2_HeartRateMonitor_t = sh2_HeartRateMonitor;
#[doc = " @brief Gyro Integrated Rotation Vector"]
#[doc = ""]
#[doc = " See SH-2 Reference Manual for details."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_GyroIntegratedRV {
    #[doc = "< @brief Quaternion component i"]
    pub i: f32,
    #[doc = "< @brief Quaternion component j"]
    pub j: f32,
    #[doc = "< @brief Quaternion component k"]
    pub k: f32,
    #[doc = "< @brief Quaternion component real"]
    pub real: f32,
    #[doc = "< @brief Angular velocity about x [rad/s]"]
    pub angVelX: f32,
    #[doc = "< @brief Angular velocity about y [rad/s]"]
    pub angVelY: f32,
    #[doc = "< @brief Angular velocity about z [rad/s]"]
    pub angVelZ: f32,
}
#[test]
fn bindgen_test_layout_sh2_GyroIntegratedRV() {
    assert_eq!(
        ::core::mem::size_of::<sh2_GyroIntegratedRV>(),
        28usize,
        concat!("Size of: ", stringify!(sh2_GyroIntegratedRV))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_GyroIntegratedRV>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_GyroIntegratedRV))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_GyroIntegratedRV>())).i as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_GyroIntegratedRV),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_GyroIntegratedRV>())).j as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_GyroIntegratedRV),
            "::",
            stringify!(j)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_GyroIntegratedRV>())).k as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_GyroIntegratedRV),
            "::",
            stringify!(k)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_GyroIntegratedRV>())).real as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_GyroIntegratedRV),
            "::",
            stringify!(real)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_GyroIntegratedRV>())).angVelX as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_GyroIntegratedRV),
            "::",
            stringify!(angVelX)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_GyroIntegratedRV>())).angVelY as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_GyroIntegratedRV),
            "::",
            stringify!(angVelY)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_GyroIntegratedRV>())).angVelZ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_GyroIntegratedRV),
            "::",
            stringify!(angVelZ)
        )
    );
}
pub type sh2_GyroIntegratedRV_t = sh2_GyroIntegratedRV;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_IZroRequest {
    pub intent: sh2_IZroMotionIntent_t,
    pub request: sh2_IZroMotionRequest_t,
}
#[test]
fn bindgen_test_layout_sh2_IZroRequest() {
    assert_eq!(
        ::core::mem::size_of::<sh2_IZroRequest>(),
        8usize,
        concat!("Size of: ", stringify!(sh2_IZroRequest))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_IZroRequest>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_IZroRequest))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_IZroRequest>())).intent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_IZroRequest),
            "::",
            stringify!(intent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_IZroRequest>())).request as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_IZroRequest),
            "::",
            stringify!(request)
        )
    );
}
pub type sh2_IZroRequest_t = sh2_IZroRequest;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sh2_SensorValue {
    #[doc = " Which sensor produced this event."]
    pub sensorId: u8,
    #[doc = " @brief 8-bit unsigned integer used to track reports."]
    #[doc = ""]
    #[doc = " The sequence number increments once for each report sent.  Gaps"]
    #[doc = " in the sequence numbers indicate missing or dropped reports."]
    pub sequence: u8,
    #[doc = "< @brief bits 7-5: reserved, 4-2: exponent delay, 1-0: Accuracy"]
    pub status: u8,
    #[doc = "< [uS]"]
    pub timestamp: u64,
    #[doc = "< @brief [uS] value is delay * 2^exponent (see status)"]
    pub delay: u32,
    pub un: sh2_SensorValue__bindgen_ty_1,
}
#[doc = " @brief Sensor Data"]
#[doc = ""]
#[doc = " Use the structure based on the value of the sensor"]
#[doc = " field."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union sh2_SensorValue__bindgen_ty_1 {
    pub rawAccelerometer: sh2_RawAccelerometer_t,
    pub accelerometer: sh2_Accelerometer_t,
    pub linearAcceleration: sh2_Accelerometer_t,
    pub gravity: sh2_Accelerometer_t,
    pub rawGyroscope: sh2_RawGyroscope_t,
    pub gyroscope: sh2_Gyroscope_t,
    pub gyroscopeUncal: sh2_GyroscopeUncalibrated_t,
    pub rawMagnetometer: sh2_RawMagnetometer_t,
    pub magneticField: sh2_MagneticField_t,
    pub magneticFieldUncal: sh2_MagneticFieldUncalibrated_t,
    pub rotationVector: sh2_RotationVectorWAcc_t,
    pub gameRotationVector: sh2_RotationVector_t,
    pub geoMagRotationVector: sh2_RotationVectorWAcc_t,
    pub pressure: sh2_Pressure_t,
    pub ambientLight: sh2_AmbientLight_t,
    pub humidity: sh2_Humidity_t,
    pub proximity: sh2_Proximity_t,
    pub temperature: sh2_Temperature_t,
    pub reserved: sh2_Reserved_t,
    pub tapDetector: sh2_TapDetector_t,
    pub stepDetector: sh2_StepDetector_t,
    pub stepCounter: sh2_StepCounter_t,
    pub sigMotion: sh2_SigMotion_t,
    pub stabilityClassifier: sh2_StabilityClassifier_t,
    pub shakeDetector: sh2_ShakeDetector_t,
    pub flipDetector: sh2_FlipDetector_t,
    pub pickupDetector: sh2_PickupDetector_t,
    pub stabilityDetector: sh2_StabilityDetector_t,
    pub personalActivityClassifier: sh2_PersonalActivityClassifier_t,
    pub sleepDetector: sh2_SleepDetector_t,
    pub tiltDetector: sh2_TiltDetector_t,
    pub pocketDetector: sh2_PocketDetector_t,
    pub circleDetector: sh2_CircleDetector_t,
    pub heartRateMonitor: sh2_HeartRateMonitor_t,
    pub arvrStabilizedRV: sh2_RotationVectorWAcc_t,
    pub arvrStabilizedGRV: sh2_RotationVector_t,
    pub gyroIntegratedRV: sh2_GyroIntegratedRV_t,
    pub izroRequest: sh2_IZroRequest_t,
}
#[test]
fn bindgen_test_layout_sh2_SensorValue__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<sh2_SensorValue__bindgen_ty_1>(),
        28usize,
        concat!("Size of: ", stringify!(sh2_SensorValue__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_SensorValue__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_SensorValue__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_SensorValue__bindgen_ty_1>())).rawAccelerometer as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(rawAccelerometer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_SensorValue__bindgen_ty_1>())).accelerometer as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(accelerometer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_SensorValue__bindgen_ty_1>())).linearAcceleration
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(linearAcceleration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_SensorValue__bindgen_ty_1>())).gravity as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(gravity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_SensorValue__bindgen_ty_1>())).rawGyroscope as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(rawGyroscope)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_SensorValue__bindgen_ty_1>())).gyroscope as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(gyroscope)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_SensorValue__bindgen_ty_1>())).gyroscopeUncal as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(gyroscopeUncal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_SensorValue__bindgen_ty_1>())).rawMagnetometer as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(rawMagnetometer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_SensorValue__bindgen_ty_1>())).magneticField as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(magneticField)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_SensorValue__bindgen_ty_1>())).magneticFieldUncal
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(magneticFieldUncal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_SensorValue__bindgen_ty_1>())).rotationVector as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(rotationVector)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_SensorValue__bindgen_ty_1>())).gameRotationVector
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(gameRotationVector)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_SensorValue__bindgen_ty_1>())).geoMagRotationVector
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(geoMagRotationVector)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_SensorValue__bindgen_ty_1>())).pressure as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(pressure)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_SensorValue__bindgen_ty_1>())).ambientLight as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(ambientLight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_SensorValue__bindgen_ty_1>())).humidity as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(humidity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_SensorValue__bindgen_ty_1>())).proximity as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(proximity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_SensorValue__bindgen_ty_1>())).temperature as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(temperature)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_SensorValue__bindgen_ty_1>())).reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_SensorValue__bindgen_ty_1>())).tapDetector as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(tapDetector)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_SensorValue__bindgen_ty_1>())).stepDetector as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(stepDetector)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_SensorValue__bindgen_ty_1>())).stepCounter as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(stepCounter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_SensorValue__bindgen_ty_1>())).sigMotion as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(sigMotion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_SensorValue__bindgen_ty_1>())).stabilityClassifier
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(stabilityClassifier)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_SensorValue__bindgen_ty_1>())).shakeDetector as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(shakeDetector)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_SensorValue__bindgen_ty_1>())).flipDetector as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(flipDetector)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_SensorValue__bindgen_ty_1>())).pickupDetector as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(pickupDetector)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_SensorValue__bindgen_ty_1>())).stabilityDetector as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(stabilityDetector)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_SensorValue__bindgen_ty_1>())).personalActivityClassifier
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(personalActivityClassifier)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_SensorValue__bindgen_ty_1>())).sleepDetector as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(sleepDetector)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_SensorValue__bindgen_ty_1>())).tiltDetector as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(tiltDetector)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_SensorValue__bindgen_ty_1>())).pocketDetector as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(pocketDetector)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_SensorValue__bindgen_ty_1>())).circleDetector as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(circleDetector)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_SensorValue__bindgen_ty_1>())).heartRateMonitor as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(heartRateMonitor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_SensorValue__bindgen_ty_1>())).arvrStabilizedRV as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(arvrStabilizedRV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_SensorValue__bindgen_ty_1>())).arvrStabilizedGRV as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(arvrStabilizedGRV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_SensorValue__bindgen_ty_1>())).gyroIntegratedRV as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(gyroIntegratedRV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sh2_SensorValue__bindgen_ty_1>())).izroRequest as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(izroRequest)
        )
    );
}
#[test]
fn bindgen_test_layout_sh2_SensorValue() {
    assert_eq!(
        ::core::mem::size_of::<sh2_SensorValue>(),
        48usize,
        concat!("Size of: ", stringify!(sh2_SensorValue))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_SensorValue>(),
        8usize,
        concat!("Alignment of ", stringify!(sh2_SensorValue))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_SensorValue>())).sensorId as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue),
            "::",
            stringify!(sensorId)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_SensorValue>())).sequence as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_SensorValue>())).status as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_SensorValue>())).timestamp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_SensorValue>())).delay as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue),
            "::",
            stringify!(delay)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sh2_SensorValue>())).un as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue),
            "::",
            stringify!(un)
        )
    );
}
pub type sh2_SensorValue_t = sh2_SensorValue;
extern "C" {
    pub fn sh2_decodeSensorEvent(
        value: *mut sh2_SensorValue_t,
        event: *const sh2_SensorEvent_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn readu8(buffer: *const u8) -> u8;
}
extern "C" {
    pub fn writeu8(buffer: *mut u8, value: u8);
}
extern "C" {
    pub fn readu16(buffer: *const u8) -> u16;
}
extern "C" {
    pub fn writeu16(buffer: *mut u8, value: u16);
}
extern "C" {
    pub fn readu32(buffer: *const u8) -> u32;
}
extern "C" {
    pub fn writeu32(buffer: *mut u8, value: u32);
}
extern "C" {
    pub fn read8(buffer: *const u8) -> i8;
}
extern "C" {
    pub fn write8(buffer: *mut u8, value: i8);
}
extern "C" {
    pub fn read16(buffer: *const u8) -> i16;
}
extern "C" {
    pub fn write16(buffer: *mut u8, value: i16);
}
extern "C" {
    pub fn read32(buffer: *const u8) -> i32;
}
extern "C" {
    pub fn write32(buffer: *mut u8, value: i32);
}
pub const shtp_Event_e_SHTP_TX_DISCARD: shtp_Event_e = 0;
pub const shtp_Event_e_SHTP_SHORT_FRAGMENT: shtp_Event_e = 1;
pub const shtp_Event_e_SHTP_TOO_LARGE_PAYLOADS: shtp_Event_e = 2;
pub const shtp_Event_e_SHTP_BAD_RX_CHAN: shtp_Event_e = 3;
pub const shtp_Event_e_SHTP_BAD_TX_CHAN: shtp_Event_e = 4;
pub type shtp_Event_e = cty::c_uint;
pub use self::shtp_Event_e as shtp_Event_t;
pub type shtp_Callback_t = ::core::option::Option<
    unsafe extern "C" fn(cookie: *mut cty::c_void, payload: *mut u8, len: u16, timestamp: u32),
>;
pub type shtp_AdvertCallback_t = ::core::option::Option<
    unsafe extern "C" fn(cookie: *mut cty::c_void, tag: u8, len: u8, value: *mut u8),
>;
pub type shtp_SendCallback_t =
    ::core::option::Option<unsafe extern "C" fn(cookie: *mut cty::c_void)>;
pub type shtp_EventCallback_t =
    ::core::option::Option<unsafe extern "C" fn(cookie: *mut cty::c_void, shtpEvent: shtp_Event_t)>;
extern "C" {
    pub fn shtp_open(pHal: *mut sh2_Hal_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn shtp_close(pShtp: *mut cty::c_void);
}
extern "C" {
    pub fn shtp_setEventCallback(
        pInstance: *mut cty::c_void,
        eventCallback: shtp_EventCallback_t,
        eventCookie: *mut cty::c_void,
    );
}
extern "C" {
    pub fn shtp_listenChan(
        pShtp: *mut cty::c_void,
        guid: u16,
        chan: *const cty::c_char,
        callback: shtp_Callback_t,
        cookie: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    pub fn shtp_listenAdvert(
        pShtp: *mut cty::c_void,
        guid: u16,
        advertCallback: shtp_AdvertCallback_t,
        cookie: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    pub fn shtp_chanNo(
        pShtp: *mut cty::c_void,
        appName: *const cty::c_char,
        chanName: *const cty::c_char,
    ) -> u8;
}
extern "C" {
    pub fn shtp_send(
        pShtp: *mut cty::c_void,
        channel: u8,
        payload: *const u8,
        len: u16,
    ) -> cty::c_int;
}
extern "C" {
    pub fn shtp_service(pShtp: *mut cty::c_void);
}
